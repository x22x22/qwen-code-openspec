# Diff for packages/sdk/typescript/test/unit/Query.test.ts
diff --git a/packages/sdk/typescript/test/unit/Query.test.ts b/packages/sdk/typescript/test/unit/Query.test.ts
new file mode 100644
index 00000000..5ceeee4b
--- /dev/null
+++ b/packages/sdk/typescript/test/unit/Query.test.ts
@@ -0,0 +1,284 @@
+/**
+ * Unit tests for Query class
+ * Tests message routing, lifecycle, and orchestration
+ */
+
+import { describe, expect, it } from 'vitest';
+
+// Note: This is a placeholder test file
+// Query will be implemented in Phase 3 Implementation (T022)
+// These tests are written first following TDD approach
+
+describe('Query', () => {
+  describe('Construction and Initialization', () => {
+    it('should create Query with transport and options', () => {
+      // Should accept Transport and CreateQueryOptions
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should generate unique session ID', () => {
+      // Each Query should have unique session_id
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should validate MCP server name conflicts', () => {
+      // Should throw if mcpServers and sdkMcpServers have same keys
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should lazy initialize on first message consumption', async () => {
+      // Should not call initialize() until messages are read
+      expect(true).toBe(true); // Placeholder
+    });
+  });
+
+  describe('Message Routing', () => {
+    it('should route user messages to CLI', async () => {
+      // Initial prompt should be sent as user message
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should route assistant messages to output stream', async () => {
+      // Assistant messages from CLI should be yielded to user
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should route tool_use messages to output stream', async () => {
+      // Tool use messages should be yielded to user
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should route tool_result messages to output stream', async () => {
+      // Tool result messages should be yielded to user
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should route result messages to output stream', async () => {
+      // Result messages should be yielded to user
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should filter keep_alive messages from output', async () => {
+      // Keep alive messages should not be yielded to user
+      expect(true).toBe(true); // Placeholder
+    });
+  });
+
+  describe('Control Plane - Permission Control', () => {
+    it('should handle can_use_tool control requests', async () => {
+      // Should invoke canUseTool callback
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should send control response with permission result', async () => {
+      // Should send response with allowed: true/false
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should default to allowing tools if no callback', async () => {
+      // If canUseTool not provided, should allow all
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should handle permission callback timeout', async () => {
+      // Should deny permission if callback exceeds 30s
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should handle permission callback errors', async () => {
+      // Should deny permission if callback throws
+      expect(true).toBe(true); // Placeholder
+    });
+  });
+
+  describe('Control Plane - MCP Messages', () => {
+    it('should route MCP messages to SDK-embedded servers', async () => {
+      // Should find SdkControlServerTransport by server name
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should handle MCP message responses', async () => {
+      // Should send response back to CLI
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should handle MCP message timeout', async () => {
+      // Should return error if MCP server doesn\'t respond in 30s
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should handle unknown MCP server names', async () => {
+      // Should return error if server name not found
+      expect(true).toBe(true); // Placeholder
+    });
+  });
+
+  describe('Control Plane - Other Requests', () => {
+    it('should handle initialize control request', async () => {
+      // Should register SDK MCP servers with CLI
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should handle interrupt control request', async () => {
+      // Should send interrupt message to CLI
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should handle set_permission_mode control request', async () => {
+      // Should send permission mode update to CLI
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should handle supported_commands control request', async () => {
+      // Should query CLI capabilities
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should handle mcp_server_status control request', async () => {
+      // Should check MCP server health
+      expect(true).toBe(true); // Placeholder
+    });
+  });
+
+  describe('Multi-Turn Conversation', () => {
+    it('should support streamInput() for follow-up messages', async () => {
+      // Should accept async iterable of messages
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should maintain session context across turns', async () => {
+      // All messages should have same session_id
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should throw if streamInput() called on closed query', async () => {
+      // Should throw Error if query is closed
+      expect(true).toBe(true); // Placeholder
+    });
+  });
+
+  describe('Lifecycle Management', () => {
+    it('should close transport on close()', async () => {
+      // Should call transport.close()
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should mark query as closed', async () => {
+      // closed flag should be true after close()
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should complete output stream on close()', async () => {
+      // inputStream should be marked done
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should be idempotent when closing multiple times', async () => {
+      // Multiple close() calls should not error
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should cleanup MCP transports on close()', async () => {
+      // Should close all SdkControlServerTransport instances
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should handle abort signal cancellation', async () => {
+      // Should abort on AbortSignal
+      expect(true).toBe(true); // Placeholder
+    });
+  });
+
+  describe('Async Iteration', () => {
+    it('should support for await loop', async () => {
+      // Should implement AsyncIterator protocol
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should yield messages in order', async () => {
+      // Messages should be yielded in received order
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should complete iteration when query closes', async () => {
+      // for await loop should exit when query closes
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should propagate transport errors', async () => {
+      // Should throw if transport encounters error
+      expect(true).toBe(true); // Placeholder
+    });
+  });
+
+  describe('Public API Methods', () => {
+    it('should provide interrupt() method', async () => {
+      // Should send interrupt control request
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should provide setPermissionMode() method', async () => {
+      // Should send set_permission_mode control request
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should provide supportedCommands() method', async () => {
+      // Should query CLI capabilities
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should provide mcpServerStatus() method', async () => {
+      // Should check MCP server health
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should throw if methods called on closed query', async () => {
+      // Public methods should throw if query is closed
+      expect(true).toBe(true); // Placeholder
+    });
+  });
+
+  describe('Error Handling', () => {
+    it('should propagate transport errors to stream', async () => {
+      // Transport errors should be surfaced in for await loop
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should handle control request timeout', async () => {
+      // Should return error if control request doesn\'t respond
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should handle malformed control responses', async () => {
+      // Should handle invalid response structures
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should handle CLI sending error message', async () => {
+      // Should yield error message to user
+      expect(true).toBe(true); // Placeholder
+    });
+  });
+
+  describe('State Management', () => {
+    it('should track pending control requests', () => {
+      // Should maintain map of request_id -> Promise
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should track SDK MCP transports', () => {
+      // Should maintain map of server_name -> SdkControlServerTransport
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should track initialization state', () => {
+      // Should have initialized Promise
+      expect(true).toBe(true); // Placeholder
+    });
+
+    it('should track closed state', () => {
+      // Should have closed boolean flag
+      expect(true).toBe(true); // Placeholder
+    });
+  });
+});
